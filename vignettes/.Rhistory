mat = matrix(0,3,3)
dim(mat)
sprintf("%s", dim(mat))
length(sprintf("%s", dim(mat)))
any(rowSums(mat == 0) == ncol(mat))
which(rowSums(mat == 0) == ncol(mat))
mat
rm(mat)
which(rowSums(mat0 == 0) == ncol(mat0))
mat(0,3,3)
mat= matrix(0,3,3)
describeMatrix(mat)
install.packages("microbenchmark")
library(microbenchmark)
microbenchmark
debugonce(benchmark)
n
timings
exprs
Q
library(irlba)
debugonce(benchmark)
n
timings
data.frame(exprs = nm, t(timings))
cbind(data.frame(exprs = nm), t(timings))
nm
exprs
exprnm
Q
fsvd(mat0)
args(prcomp_irlba)
prcomp.irlba
library(irlba)
prcomp.irlba
prcomp_irlba
tmp = prcomp_fsvd1(mat0)
ls()
rm(out)
ls()
prcomp_fsvd1(mat0)
library(matrixStats)
prcomp_fsvd1(mat0)
tmp = prcomp_fsvd1(mat0)
ref = prcomp(mat0, scale = TRUE)
all.equal(tmp$sdev, ref$sdev)
all.equal(tmp$sdev, ref$sdev[1:3])
tmp$sdev
ref$sdev[1:3]
prcomp_irlba
tmp = prcomp_fsvd1(mat0)
all.equal(tmp$sdev, ref$sdev[1:3])
prcomp_irlba
tmp = prcomp_fsvd1(mat0)
all.equal(tmp$sdev, ref$sdev[1:3])
tmp$sdev
ref$sdev[1:3]
ref = prcomp(mat0, scale = TRUE, center = TRUE)
ref$sdev[1:3]
ref = prcomp(t(mat0), scale = TRUE, center = TRUE)
head(ref$sdev)
tmp$sdev
tmp = prcomp_fsvd1(mat0)
all.equal(tmp$sdev, ref$sdev[1:3])
tmp$sdev
head(ref$sdev)
stats:::prcomp.default
tmp1 = fsvd(mat0)
tmp1 = fsvd(mat0, k = 10)
tmp2 = svd(mat0)
head(tmp2$d)
head(tmp1$d)
tmp1 = fsvd(mat0, k = 10, i = 3)
head(tmp1$d)
head(tmp2$d)
tmp = prcomp_fsvd1(mat0, i = 5)
all.equal(tmp$sdev, ref$sdev[1:3])
all.equal(tmp$rotation, ref$rotation[,1:3])
dim(ref$rotation)
dim(tmp$rotation)
tmp = prcomp_fsvd1(mat0, i = 5)
all.equal(tmp$rotation, ref$rotation[,1:3])
dim(tmp$rotation)
head(tmp$rotation)
head(ref$rotation[, 1:3])
all.equal(abs(tmp$rotation), abs(ref$rotation[,1:3]))
all.equal(abs(tmp$x), abs(ref$x[,1:3]))
dim(tmp$x)
dim(ref$x)
all.equal(abs(tmp$x), abs(ref$x[,1:3]))
dim(tmp$x)
dim(tmp1$u)
dim(tmp1$v)
dim(ref$x)
dim(tmp$x)
args(sweep)
tmp = prcomp_fsvd1(mat0, i = 5)
dim(tmp$x)
all.equal(tmp$x, ref$x)
all.equal(tmp$x, ref$x[,1:3])
head(tmp$x)
head(ref$x[,1:3])
all.equal(abs(tmp$x), abs(ref$x[,1:3]))
ref1
head(ref$sdev)
head(ref.fsvd1$sdev)
dim(ref$rotation)
dim(ref.irlsba$rotation)
dim(ref.irlba$rotation)
head(ref$rotation[,1:10])
head(ref.irlba$rotation[,1:10])
library(Matrix)
test = Matrix(0, ncol = 10^8, nrow = 1000)
test
head(test)
prod(dim(test))
.Machine$integer.max
.Machine$integer.max / 10^9
?dgCMatrix
class?dgCMatrix
test = Matrix(rnorm(10^11), ncol = 10^8, nrow = 1000)
mat0.dge
head(mat0.dge)
mat0.dge[1:5,1:5]
mat0.dgC[1:5,1:5]
prcomp_irlba
csds
length(csds)
BiocManager::install("TENxPBMCData")
a
BiocManager::version()
tenx
prod(dim(tenx))
prod(dim(tenx)) / 10^9
.Machine$integer.max/ 10^9
library(pryr)
object_size(tenx.c1)
rm(tenx.c1)
gc()
object_size(tenx.c1)
object_size(tenc.dgC1)
object_size(tenx.dgC1)
kdh$size()
rm(mat.dge)
rm(mat, test, )
rm(mat, test)
kdh$size()
k
kdh$size()
head(cmeans)
library(irlba)
?irlba
rm(tmat0)
rm(tmat)
class(tmat0.h5a)
showMethods("%*%")
class(tmat0.h5a)
tim(tmat0)
dim(tmat0)
library(BiocManager)
getClass("HDF5Matrix")
library(help = DelayedArray)
?blockGrid
chunkGrid(tmat0.h5a)\
chunkGrid(tmat0.h5a)
blockGrid(tmat0.h5a)
?blockGrid
rowGrid(tmat0.h5a)
rowGrid(tmat0.h5a, block.length = dim(prod(chunkGrid(tmat0.h5a))))
rowGrid(tmat0.h5a, block.length = prod(dim(chunkGrid(tmat0.h5a)))))
chunkGrid(tmat0.h5a)
dim(chunkGrid(tmat0.h5a))
dim(chunkGrid(tmat0.h5a)[1,1])
chunkGrid(tmat0.h5a)
seq_along(chunkGrid(tmat0.h5a))
args(read <- block)
args(read_block)
read_block(tmat0.h5a, chunkGrid(tmat0.h5a)[[1]])
chunkGrid(tmat0.h5a)
chunkGrid(tmat0.h5a)[1]
chunkGrid(tmat0.h5a)[[1]]
blockGrid(tmat0.h5a)[[1]]
grid <- chunkGrid(tmat0.h5a)
grid
seq_along(grid)
grid[1]
grid[[1]]
grid
yy = rnorm(1946)
yy = rnorm(1846)
dim(tmat0)
yy = rnorm(1000)
length(unlist(out))
a = matrix(1:6, ncol = 2)
a
y = 3:4
y %*% A
y %*% a
y = 1:3
y %*% A
y %*% a
a %*% y
y = 1:2
y*%* a
a %*% y
args(setClass)
class(tmat0.h5a)
dim(tmat0)
testObject %*% rnorm(ncol(tmat0))
irlba
names(out)
dim(out$v)
dim(tmat0)
dim(out2$v)
dim(out$v)
dim(testObject2)
mat.h5.rows
mat.h5a.rows
dim(testObject2@rowAccess)
dim(testObject2@colAccess)
dim(testObject2)
dim(mat)
names(out)
dim(out$v)
dim(out$u)
names(out)
names(out2)
out2$iter
out$iter
dim(out2$v)
chunkGrid(tmat.dc)
chunkGrid(tmat.dc@rowAccess)
chunkGrid(tmat.dc@rowAccess)[1]
chunkGrid(tmat.dc@rowAccess)[[1]]
q()
traceback()
dim(mat)
out$iter
length(tmp)
nrow(mat) * 50
prod(dim(mat))
ncol(mat)
nrow(mat) * 50 / ncol(mat)
()
q()
mat.h5a.rows
rm(mat.h5a.rows)
mat.h5a.rows = HDFMatrix(file.path(dataDir, "mat_rows.h5"))
mat.h5a.rows = HDF5Matrix(file.path(dataDir, "mat_rows.h5"))
?HDF5Matrix
q()
args(blockApply)
SingleCoreParam()
SerialParam()
out$iter
out2$iter
grid <- chunkGrid(mat.h5a.rows)
grid
grid[[1]]
grid[[1L]]
ranges(grid[[1L]])
ranges(grid[[2L]])
ranges(grid[[2L]])[1]
as.integer(ranges(grid[[2L]])[1])
as(ranges(grid[[2L]])[1], "integer")
as(ranges(grid[[2L]])[1], "numeric")
n
class(block)
dim(block)
Q
n
dim(block)
Q
args(scale)
all.equal(tmp, correct)
class(tmp)
all.equal(tmp, as.numeric(correct))
head(tmp)
head(correct)
all.equal(tmp, as.numeric(correct))
head(tmp)
head(correct)
head(tmp) / head(correct)
?scale
dim(t(scale(tmat)))
rm(yy)
rm(correct, tmp)
head(correct1)
head(correct2)
head(tmp1)
1:2 %*% matrix(1:6, ncol = 2 <- 
1:2 %*% matrix(1:6, ncol = 2)
1:3 %*% matrix(1:6, ncol = 2)
dim(correct1)
dim(tmp1)
attributes(correct1)
correct$iter
chunkGrid(y@colAccess)
chunkGrid(mat.dc@colAccess)
chunkGrid(mat.dc@rowAccess)
462 / 20
54 / 1.3
24/8
41+3/2
chunkGrid(mat.dc@rowAccess)
ranges(chunkGrid(mat.dc@rowAccess)[[1L]])
ranges(chunkGrid(mat.dc@colAccess)[[1L]])
1500*1846
54290*50
describeMatrix(mat)
library(Matrix)
?sparseMatrix
block
block %*% y
Q
read_block
showMethods("read_block")
getMethods("read_block")
getMethod("read_block", "HDF5Matrix")
getMethod("read_block", signature(x = "HDF5Matrix"))
getAnywhere("read_block")
read <- block
system.time({sparseMat %*% yy1})
system.time({mat %*% yy1})
system.time({yy %*% sparseMat})
system.time({yy2 %*% sparseMat})
system.time({yy2 %*% mat})
q()
tenx
library(pryr)
object_size(tenx.c1)
rm(tenx.c1)
ncol(mat)
traceback()
q()
